<!doctype html>
	<head>
		<link rel="icon" type="image/x-icon" class="js-site-favicon" href="resource/personal/favicon.ico">
		<title>Dreamline91's homepage</title>
		<script type="text/javascript" src="resource/external/three.min.js"></script>
		<style>
			html, body { 
				margin: 0;
				overflow: hidden; 
			}
		</style>
	</head>
	<body>
		<script>
			var camera, scene, renderer;

			var geometry, material, mesh, loader;

			var particles_fire;
			var particle;
			const NUM_FIRE = 1500;
			const DELTA_Y_FIRE = 5;
			const DELTA_Z_FIRE = -2;
			const RANGE_PX_FIRE = 2.5;
			const RANGE_PY_FIRE = 1.5;
			const RANGE_VX_FIRE = 0.05;
			const RANGE_VY_FIRE = 0.10;
			const RANGE_AY_FIRE = 0.002;
			const RANGE_DEGREE = Math.PI / 180 * 360;
			const DELTA_FRAME = 0.005;
			const RANGE_FRAME = 0.005;

			var clock, bird, mixer, actions, index = 0;

			init();
			animate();

			function init(){
				var width = window.innerWidth;
				var height = window.innerHeight;

				camera = new THREE.PerspectiveCamera(50, width / height, 1, 1000);
				camera.position.y = 15;
				camera.position.z = 30;
				camera.up.set(0, 30, 15);

				renderer = new THREE.WebGLRenderer({
					antialias: true, 
					alpha: true
				});
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.autoClear = false;
				renderer.shadowMap.enabled = true;

				document.body.appendChild(renderer.domElement);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x000000);

				geometry = new THREE.PlaneGeometry(60, 60, 1, 1);
				material = new THREE.MeshPhongMaterial({color: 0xcccccc});
				mesh = new THREE.Mesh(geometry, material);
				mesh.rotation.x = -0.5 * Math.PI;
				mesh.receiveShadow = true;
				scene.add(mesh);

				particles_fire = new Array();
				for(var i = 0; i < NUM_FIRE; ++i){
					particles_fire[i] = {
						mesh: null,
						c: 0x3fffff,
						t: 1.0, 
						r: DELTA_FRAME + Math.random() * RANGE_FRAME,
						p: [(Math.random() * RANGE_PX_FIRE) * Math.cos(Math.random() * RANGE_DEGREE), (Math.random() * RANGE_PY_FIRE) * Math.sin(Math.random() * RANGE_DEGREE) + DELTA_Y_FIRE, DELTA_Z_FIRE], 
						v: [(Math.random() * RANGE_VX_FIRE) * Math.cos(Math.random() * RANGE_DEGREE), (Math.random() * RANGE_VY_FIRE) * Math.sin(Math.random() * RANGE_DEGREE), 0], 
						a: [0, RANGE_AY_FIRE, 0]
					};
					particle = particles_fire[i];
					geometry = new THREE.PlaneGeometry(3, 5);
					material = new THREE.MeshPhongMaterial({
						color: 0x3fffff,
						map: new THREE.TextureLoader().load("resource/fire.png"),
						transparent: true,
						depthWrite: false,
						opacity: particle.t,
						blending: THREE.AdditiveBlending
					});
					particle.mesh = new THREE.Mesh(geometry, material);
					particle.mesh.castShadow = true;
					particle.mesh.receiveShadow = true;
					scene.add(particle.mesh);
					particle.mesh.position.set(particle.p[0], particle.p[1], particle.p[2]);
				}

				new THREE.JSONLoader().load("resource/dreamline91.json", function (geometry, materials) {
					material = new THREE.MeshPhongMaterial({
						transparent: true
					});
					material.emissive = {b: 0.3, g: 0.3, r: 0.3};
					mesh = new THREE.Mesh(geometry, material);
					mesh.position.set(0, 1.4, -2.5);
					mesh.rotation.y = -0.5 * Math.PI;
					mesh.scale.set(2, 2, 2);
					mesh.castShadow = true;
					scene.add(mesh);
				});

				clock = new THREE.Clock();
				new THREE.JSONLoader().load("resource/personal/bird.json", function (geometry, materials) {
					materials.forEach(function (material) { 
						material.specular = {b: 0.05, g: 0.05, r: 0.05};
						material.skinning = true;
						material.opacity = 0.3;
						material.transparent = true;
						material.color = {b: 1, g: 1, r: 1};
						material.side = THREE.FrontSide;
						material.blending = THREE.CustomBlending;
						material.blendEquation = THREE.AddEquation;
						material.blendSrc = THREE.OneFactor;
						material.blendDst = THREE.OneMinusSrcAlphaFactor;

					});
					materials[1].color = {b: 0, g: 1, r: 1};
					materials[2].specular = {b: 1, g: 1, r: 1};
					materials[3].specular = {b: 0, g: 0, r: 0};

					bird = new THREE.SkinnedMesh(geometry, new THREE.MeshFaceMaterial(materials));
					bird.position.set(0, 9, 1.5);
					bird.scale.set(0.01, 0.01, 0.01);
					bird.rotation.x = 0.05 * Math.PI;
					mixer = new THREE.AnimationMixer(bird);
					actions = new Array(geometry.animations.length);
					for(var i = 0; i < actions.length; i++){
						actions[i] = mixer.clipAction(geometry.animations[i]);
						actions[i].setEffectiveWeight(1);
						actions[i].enabled = true;
					}
					scene.add(bird);
				});


				var light = new THREE.SpotLight(0xffffff);
				light.position.set(0, 12, 16);  
				light.castShadow = true;
				light.shadow.mapSize.width = 5120;
				light.shadow.mapSize.height = 5120;
				scene.add(light);  
			}

			function animate() {


				requestAnimationFrame(animate);
				renderer.clear();
				
				for(var i = 0; i < NUM_FIRE; ++i){
					particle = particles_fire[i];
	
					particle.t -= particle.r;
					if(particle.t < 0) {
						particle.t = 1.0;
						particle.c = 0x3fffff;
						particle.r = DELTA_FRAME + Math.random() * RANGE_FRAME;
						particle.p = [(Math.random() * RANGE_PX_FIRE) * Math.cos(Math.random() * RANGE_DEGREE), (Math.random() * RANGE_PY_FIRE) * Math.sin(Math.random() * RANGE_DEGREE) + DELTA_Y_FIRE, DELTA_Z_FIRE]; 
						particle.v = [(Math.random() * RANGE_VX_FIRE) * Math.cos(Math.random() * RANGE_DEGREE), (Math.random() * RANGE_VY_FIRE) * Math.sin(Math.random() * RANGE_DEGREE), 0]; 

						if(index == 0){
							bird.scale.set(1.25, 1.25, 1.25);
							var from = actions[index].play();
							index = 2;
							setTimeout(function() {
								bird.position.set(7.5, 9, 1.5);
								var to = actions[index].play();	
								from.enabled = true;
								to.enabled = true;
								from.crossFadeTo(to, 0);
							}, 2500);
						}
					} else {	
						particle.c = ((63 - 63 * (1 - particle.t)) << 16) + ((255 - 255 * (1 - particle.t)) << 8) + (255 - 255 * (1 - particle.t))
						particle.p = [particle.p[0] + particle.v[0] * (1 - particle.t), particle.p[1] + particle.v[1] * (1 - particle.t), DELTA_Z_FIRE]
						particle.v[1] = particle.v[1] + particle.a[1];
					}
					particle.mesh.material.opacity = particle.t;
					particle.mesh.material.color.setHex(particle.c);
					particle.mesh.position.set(particle.p[0], particle.p[1], particle.p[2]);
				}
				
				if(mixer)
					mixer.update(clock.getDelta());

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>